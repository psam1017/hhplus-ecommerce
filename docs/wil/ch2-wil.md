# 항해플러스 시나리오 기반 서버 구축 회고록

## 목차
- [프로젝트 개요 및 목표](#프로젝트-개요-및-목표)
- [3주차 후기](#3주차-후기)
- [4주차 후기](#4주차-후기)
- [5주차 후기](#5주차-후기)
- [어려웠던 과제와 극복 과정](#어려웠던-과제와-극복-과정)
- [3주간의 여정을 통해 배운 것들](#3주간의-여정을-통해-배운-것들)

---

## 프로젝트 개요 및 목표
<details>
  <summary>프로젝트 개요 및 목표</summary>

제가 속한 8조는 다수결로 전원 **이커머스 시나리오**에 맞춰 개발을 하기로 했습니다. 이커머스는 **상품, 포인트, 장바구니, 주문** 4가지의 도메인을 대상으로 한 로직 개발을 해야 합니다.

- 아키텍처와 테스트에 집중하며, 시나리오 기반 서버 애플리케이션 구축
- 아키텍처와 테스트 코드 작성에 집중하며, 견고하고 유연한 서버 개발을 지향
- 3주차 과제: 시나리오 선정 및 프로젝트 마일스톤, 요구사항 분석자료, ERD, Mock API, API Specification 작성
- 4주차 과제: 비즈니스 로직 개발 및 단위 테스트, Usecase 개발 및 통합테스트, API Swagger 구현
- 5주차 과제: RestControllerAdvice, Filter, Interceptor로 관점 분리 개발, 동시성 통합 테스트 및 회고록 작성

</details>

## 3주차 후기
<details>
  <summary>3주차 후기</summary>

3주차는 주로 문서를 작성하는 주간이었습니다. 작성한 대부분의 문서들이 회사에서 한 번 시도했지만 제대로 동료들의 동의를 얻지 못 해 한동안 머리 속에서 잊고 있었던 내용들이었습니다.

오랜만에 다시 작성하다 보니 조금 버벅이기도 했지만, 막막할 정도는 아니었습니다. 잘 작성되었는지 여부와는 별개로, 이런저런 고민을 해본 것은 가치 있는 시간이었고, 다른 개발자들의 문서를 보며 비교할 수 있어서 좋았습니다.

가장 어려웠던 부분은 **문서 작성보다는 패키지 구조를 잡아가는 과정**이었습니다. 스프링이라는 기술 자체는 1년 넘게 실무에서 사용해왔지만, 트랜잭션 스크립트 패턴과 도메인 모델 패턴이 혼재된 애매한 Service 클래스를 만들어왔기 때문에 좀 더 도메인 지향적인 개발을 하기 위해 많은 고민이 필요했습니다.

이러한 고민 끝에 **interfaces, application, domain, infrastructure**의 4가지 패키지로 나누었고, 각각에 API 책임, 도메인 로직의 조합 및 비즈니스 로직의 완성 책임, 도메인 로직 책임, 다른 계층을 지원하는 책임을 부여했습니다.

3주차는 완전히 만족스럽지는 않았지만, 제 나름대로 **책임을 분리하는 아키텍처를 고안**할 수 있었던 의미 있는 시간이었습니다.

</details>

## 4주차 후기
<details>
  <summary>4주차 후기</summary>

4주차는 본격적인 기능 개발 차례입니다. 포인트, 상품, 장바구니, 주문 각각에 대해 필요한 기능을 구현했고, 더 많은 여러 가지의 기능보다는 완성도 있는 기능을 개발하고자 했습니다.

아키텍처 측면에서 저의 기존 개발 방식과 가장 크게 달라진 점은, **application에서 Facade 패턴을 사용**해 도메인 로직을 조합하고 비즈니스 로직을 완성하는 Facade 클래스를 둔 것이었습니다.

사실 이 디자인 패턴 자체를 알기 전에도 필요에 의해 유사하게 사용해본 경험이 있습니다. 과제와 비슷하게 이커머스를 개발할 때였는데, **상품 등록 로직에서 한 번의 트랜잭션으로 저장해야 할 것이 너무 많아서(카테고리, 연관상품 등등)**, 코드가 몇 백 줄에 달하며 관리가 어려워지자 Service를 나누었던 적이 있습니다.

그 당시에는 네이밍이나 디자인 패턴에 대해 잘 알지 못해서 `XxxIntegrationService`라는 이름을 붙였는데, 도메인 별로 무거운 Service를 나누는 것에 불과해 도메인 주도적인 로직은 아니었습니다. 그래도 한 번 고민하면서 직접 패턴을 고안해본 경험이 있기 때문인지 비교적 수월하게 이를 적용할 수 있었습니다.

이러한 경험을 떠올리면서 도메인 서비스는 **하나의 로직, 하나의 행동만 수행하도록 얇게 정의**했고, Facade에서는 **필요한 Service를 모아 하나의 비즈니스 로직을 완성**하도록 했습니다.

처음에는 이렇게 만드는 것이 괜히 복잡도를 높이고 불필요한 테스트를 늘리는 게 아닌가 하는 생각도 들었습니다. 하지만 계속 작업하다 보니 3가지의 장점을 느낄 수 있었습니다.

1. 하나의 메서드에 담긴 로직이 작아서 이해하기 쉽다.
2. 테스트 대상이 조금 늘어났어도, 그 대상들을 테스트하는 코드도 단순해져 결과적으로는 비슷하다.
3. 이러한 결과로, 장기적으로 봤을 때 테스트의 유지보수도 쉬워진다(는 생각이 들었습니다).

4주차 과제는 확실히 3주차나 5주차보다 많았지만, 집중해서 작업하다 보니 할 만했고 **새로운 아키텍처로 개발을 시도해 보는 의미 있는 시간**이었습니다.

</details>

## 5주차 후기
<details>
  <summary>5주차 후기</summary>

5주차는 개발된 기능들을 **완성하는 주차**였습니다. 비즈니스 로직의 방향을 가로지르는 **관점 분리 개발**이 필요했습니다. 이에 **예외 처리를 위한 ControllerAdvice, Filter, Interceptor를 추가 및 테스트**했고, **동시성 테스트 및 API 완성**이 필요했는데...

사실 언급된 내용들이 지난 주차에서 이미 적용하거나, 일부는 불필요해서 다시 삭제했던 것들이라서 이를 마무리하는 데 시간이 오래 걸리진 않았습니다. 대신 4주차가 좀 고생이었죠.

그래서 이번에는 그동안 시도해보지 않았던 **Filter와 Interceptor의 테스트**를 진행해 보았습니다. `MockHttpServletRequest`, `MockHttpServletResponse`, `MockFilterChain`을 활용해 **필터 테스트**를 진행했고, **Interceptor에서는 내부적으로 동작하는 클래스의 실행 여부를 검증**하는 방식으로 테스트를 수행했습니다.

평소에는 Filter와 Interceptor를 테스트하지 않았지만 고민하면서 테스트를 마치고 보니 문득 과거에 이러한 부분에서 예외가 발생했던 경험이 떠올라 이번 기회를 통해 이러한 테스트의 필요성을 다시 한 번 느끼게 되었습니다.

5주차는 **관점 분리 로직에 대해 다시 한 번 고민하고 이를 테스트해보는 시간**이었습니다.

</details>

## 어려웠던 과제와 극복 과정
<details>
  <summary>어려웠던 과제와 극복 과정</summary>

역시 가장 어려웠던 부분은 **아키텍처를 고안하는 부분**이었습니다. 평소에 **Layered Architecture**로 개발했고, **Repository에서 DIP를 적용해야겠다는 생각은 하지 않았어서** 한동안 그것의 가치를 잊고 지냈는데, 다시 한 번 되새기는 시간이었습니다.

다만 '정말로 필요한 상황'에 대해 고민을 하게 되었습니다. 예를 들어 도메인 엔티티를 POJO로 만들고, 이를 적극 활용하여 도메인에서 외부에 대한 의존성을 제대로 분리할 필요가 있는, 장기적인 유지보수가 필요한 서비스에 대해서는 **Clean + Layered Architecture**의 필요성을 느꼈습니다.

하지만 유지보수나 기술의 변경이 적은, 또는 규모가 크지 않은 서비스에 대해서는 무엇이 필요한지에 대해 고민해보고 결정하는 것이 좋다는 생각도 듭니다. 정작 오지도 않을 상황, 쓰지도 않을 유연성을 위해서 불필요한 설계는 사실 필요하지 않습니다. 그럼에도 불구하고 우리 회사에서 개발한 시스템이 어디까지 확장되고 발전할지는 누구도 예측할 수 없는 일이기에 이에 대비하는 것도 필요하겠죠. 어려운 일이지만 아키텍처 중 어떤 것이 가장 최고다, 라는 것은 없다고 보기에 지금 진행하는 프로젝트에 대해 최선의 선택과 최소한의 확장성이 필요하다는 결론에 다다렀습니다.

확실히 이전과 달라진 점이 있다면 이제 저에게는 적용할 아키텍처를 고를 **선택지가 늘었다**는 것이고, 이는 분명 장래에 유익한 도움이 될 것이라는 확신이 생겼습니다.

두 번째 어려운 점은 **퍼사드에서 얼마나 로직을 수행하고, 서비스에서는 얼마나 로직을 수행할지**에 대한 것이었습니다. 퍼사드를 사용하는 시도 자체는 좋았으나, 퍼사드에 너무 집중하다 보니 서비스가 너무 단순해져 버렸습니다. 거의 Repository의 메서드를 호출하여 쿼리 또는 업데이트만 하는 수준이 되었습니다.

이에 따라 퍼사드에 구체적인 로직들이 몰리게 되었고, 4주차 멘토 코치님께서 피드백을 주신 덕분에 '하나의 행동'을 각 서비스에서 하나씩 처리하는 방식으로 코드를 변경했습니다.

기존에는 서비스 코드가 한두 줄이고 퍼사드가 여러 줄이었다면, 변경 후에는 서비스 코드가 세네 줄로 늘리고, 길었던 퍼사드 코드는 그 길이를 약 50% 이하로 줄이면서 **가독성과 서비스의 기능 단위를 좀 더 명확하게** 할 수 있었습니다.

</details>

## 3주간의 여정을 통해 배운 것들
<details>
  <summary>3주간의 여정을 통해 배운 것들</summary>

제가 배운 것은 한 마디로 **나 혼자 읽기 좋은 코드보다, 모두가 읽기 좋은 코드 만들기**입니다.

저는 그동안 의존성이나 DIP, 로직의 분리에 크게 신경을 쓰지 않고 코드를 작성해왔습니다. 회사에서 백엔드를 혼자 맡다 보니 이런 습관이 더 강해졌던 것 같습니다.

하지만 이번 프로젝트를 통해 **계층과 책임을 명확히 분리하고, 각 클래스와 모듈이 맡아야 할 역할을 명확히 정의**하는 것이 유지보수성과 가독성에 큰 도움이 된다는 것을 깨달았습니다. 이렇게 하면 전체적으로 모두가 이해하기 좋은 코드가 될 수 있겠다는 확신이 들었습니다.

멘토링 중에 "**좋은 코드는 신규 직원이 들어와도 바로 이해할 수 있는 코드**"라는 말이 기억에 남습니다. 이에 깊이 공감하며, 앞으로는 더 나은 코드를 작성하기 위해 지속적으로 고민해 나가고자 합니다.

</details>