# 이커머스 동시성 이슈 분석 보고서

## 목차
- [동시성 이슈란?](#동시성-이슈란)
- [이커머스 시나리오에서 발생할 수 있는 동시성 이슈](#이커머스-시나리오에서-발생할-수-있는-동시성-이슈)
- [동시성 제어를 위한 락](#동시성-제어를-위한-락)
- [데드락](#데드락)
- [동시성 제어 방식](#동시성-제어-방식)

---

## 동시성 이슈란?
<details>
  <summary>동시성 이슈란?</summary>

동시성 이슈란 공유될 수 있는 하나의 자원에 대해 여러 트랜잭션, 스레드, 프로세스 또는 작업 등이 동시에 접근할 때 충돌이 일어나는 것을 의미합니다.

예를 들어, 하나의 자원이 속성으로 0이라는 값을 가지고 있을 때, 1씩 증가하는 요청을 여러 번 한다고 가정해봅시다.

만약 이 요청이 순차적으로 발생히여 충돌이 생기지 않는다고 하면 다음과 같이 수정됩니다. 

- A : 현재값(0) + 1 -> 1 로 업데이트
- B : 현재값(1) + 1 -> 2 로 업데이트
- C : 현재값(2) + 1 -> 3 로 업데이트
- ...

하지만, 이 요청이 순차적으로 발생한 게 아니라 동시에 발생한다면 다음과 같이 수정됩니다.

- A : 현재값(0) + 1 -> 1 로 업데이트
- A' : 현재값(0) + 1 -> 1 로 업데이트
- A'' : 현재값(0) + 1 -> 1 로 업데이트
- ...

이렇게 충돌이 발생하면 1씩 증가하는 요청을 아무리 여러 번 요청하더라도 그 값이 제대로 반영되지 않을 수 있기 때문에 동시성 이슈가 발생하지 않도록 제어하는 것은 굉장히 중요합니다.

이것을 보고 소위 '동시성 제어'라고 합니다.

</details>

## 이커머스 시나리오에서 발생할 수 있는 동시성 이슈

<details>
  <summary>이커머스 시나리오에서 발생할 수 있는 동시성 이슈</summary>

- 이커머스 시나리오 프로젝트에서도 동시성 이슈가 발생할 수 있는 솽황이 3가지 있습니다.

### 포인트 충전을 위해 포인트 레코드에 접근

포인트를 충전하는 상황에서 여러 번의 결제를 수행하더라도 1번만 포인트가 충전되는 문제 상황이 생길 수 있습니다.

- A : 현재 포인트(100) + 100 -> 200 으로 업데이트
- A' : 현재 포인트(100) + 100 -> 200 으로 업데이트
- A'' : 현재 포인트(100) + 100 -> 200 으로 업데이트

### 주문/결제 시 - 포인트 감소를 위해 포인트 레코드에 접근

포인트를 사용하여 주문을 하는 상황에서 여러 번 주문을 했음에도 1번만 포인트가 사용되는 문제 상황이 생길 수 있습니다.

- B : 현재 포인트(1000) - 100 -> 900 으로 업데이트
- B' : 현재 포인트(1000) - 100 -> 900 으로 업데이트
- B'' : 현재 포인트(1000) - 100 -> 900 으로 업데이트

### 주문/결제 시 - 재고 차감을 위해 재고 레코드에 접근

1개 밖에 남지 않은 상품을 주문할 때 여러 번의 주문 모두가 구매에 성공하는 문제 상황이 생길 수 있습니다.

- C : 현재 재고수량(1) - 1 -> 0 으로 업데이트 && 주문 성공
- C' : 현재 재고수량(1) - 1 -> 0 으로 업데이트 && 주문 성공
- C'' : 현재 재고수량(1) - 1 -> 0 으로 업데이트 && 주문 성공

</details>

## 동시성 제어를 위한 락

<details>
  <summary>동시성 제어를 위한 락</summary>

동시성 이슈를 해결하기 위해서는 락(Lock)이라는 개념을 사용합니다. 락은 공유 자원에 대한 접근을 제어하여 동시에 여러 프로세스나 스레드가 동일한 자원에 접근하는 것을 방지하는 메커니즘입니다. 이를 통해 데이터의 무결성을 유지하고 예기치 않은 충돌이나 오류를 예방할 수 있습니다.

### 낙관적 락과 비관적 락
락에는 낙관적 락과 비관적 락이 있습니다.

- 낙관적 락
  - 데이터 충돌이 드물다고 가정하고, 데이터 수정 시 충돌 여부를 검사하여 문제가 없으면 업데이트를 진행합니다.
  - 버전 번호 또는 타임스탬프를 이용하여 데이터 변경 여부를 확인합니다.
  - 락을 걸지 않기에 시스템 성능 저하가 적다는 장점이 있습니다.
  - 충돌이 발생하면 재시도 로직이 필요할 수 있으며, 동시에 여러 충돌이 발생하여 실패하면 10번 성공해야 할 게 7번만 성공하는 등 문제가 생길 수 있습니다.
  - 결과적으로 성공횟수에 비해 더 많은 로직을 수행해야 하므로 낭비가 발생할 수 있습니다.
  - 따라서 충돌이 드물거나, 또는 한 건만 성공하면 되는 경우 등의 상황에서 적합합니다.
- 비관적 락
  - 데이터 충돌이 빈번하다고 가정하고, 데이터에 접근할 때 락을 걸고 다른 작업을 접근하지 못 하게 막습니다.
  - java 의 synchronized, db 의 select ... for update 등 시스템적인 방법이 있습니다.
  - 데이터 충돌을 사전에 방지하여 안정성을 높일 수 있다는 장점이 있습니다.
  - 락에 따른 대기 시간이 발생하여 성능이 저하될 수 있습니다.
  - 충돌이 빈번하거나, 여러 건의 시도가 하나씩 성공해야 하는 경우 등의 상황에서 적합합니다.

</details>

## 데드락

<details>
  <summary>데드락</summary>

### 데드락의 개념

락에 의해 발생할 수 있는 사이드 이펙트로 데드락이라는 것이 있습니다. 데드락은 서로 다른 작업이 각자에게 필요로 하는 자원을 상대방이 소유하고 있어서 서로의 작업이 끝나기를 대기해버리는 상황입니다.

![데드락 이미지](https://github.com/user-attachments/assets/7d51cb86-5988-4b9f-8ac8-98ecdb98dd5f)

### 데드락 발생 요건

데드락은 아래 4가지 조건이 모두 만족되는 경우 발생될 수 있습니다. 참고로, 데드락은 비단 DB 만에서 발생하는 것이 아니라 컴퓨터 전반에서 발생할 수 있는 현상입니다. 이번 보고서에서는 DB 에서 발생하는 데드락에 초점을 두고 설명합니다.

1. 상호배제
    - 하나의 리소스는 한 번에 한 프로세스(스레드, 트랜잭션 등)만 사용할 수 있다. 즉, 그 리소스가 어떤 프로세스에 의해 잠금이 걸려있다.
    - 사용 중인 자원을 다른 프로세스가 요청하려면 그 자원에 대한 잠금이 해제될 때까지 기다려야 한다.
2. 점유와 대기
    - 한 프로세스가 한 개 이상의 리소스를 보유한 상태(점유)에서 다른 프로세스의 자원을 점유하기 위해 대기하고 있는 상황이다.
3. 비선점
    - 다른 프로세스가 점유한 자원을 강제로 가져올 수 없다. 즉, 그 프로세스가 자원에 대한 잠금을 해제할 때까지 기다려야 한다.
4. 순환 대기
    - 대기 중인 프로세스들이 서로를 기다리고 있어야 한다.

예를 들어, 언급한 재고 차감 상황에 데드락 발생 요건을 적용해보겠습니다.

트랜잭션이 TX1, TX2 로 2개가 있고, 상품은 A, B 2개가 있다고 가정해봅시다.

1. 상호배제
    - TX1 은 상품 A, B 를 잠급니다. 이때 비관적 락이 사용됩니다.
    - TX2 는 상품 A, B 를 잠급니다. 이때 역시 비관적 락이 사용됩니다.
2. 점유와 대기
    - TX1 은 상품 A 를 먼저 잠갔습니다. 그리고 이제 상품 B 를 잠글 차례입니다.
    - TX2 는 상품 B 를 먼저 잠갔습니다. 그리고 이제 상품 A 를 잠글 차례입니다.
    - 하지만 두 트랜잭션이 서로에게 필요한 상품을 잠갔기에 대기해야 하는 상황입니다.
3. 비선점
    - TX1 은 TX2 가 점유한 상품 B 를 강제로 가져올 수 없습니다.
    - 마찬가지로 TX2 는 TX1 이 점유한 상품 A 를 강제로 가져올 수 없습니다.
4. 순환 대기
    - TX1 과 TX2 는 각자에게 필요한 자원을 서로가 기다리고 있기 때문에 순환 대기 구조가 형성됩니다.

만약, 이 상황에서 서로가 동일한 시간 동안 락을 획득하지 못 한다면 두 트랜잭션 모두 실패로 끝나게 될 것입니다.

### 데드락 해결방법

데드락은 예방, 회피, 탐지&복구 등의 방법으로 해결할 수 있습니다.

이 중에서 회피 방법과 탐지&복구 방법은 데드락 회피를 위한 알고리즘적 접근이 필요하기에 필요 이상의 오버헤드라고 판단하고 예방 기법을 사용했습니다.
단, 예방기법은 불필요한 대기를 해야 하거나, 더 많은 시도를 해야 하는 등 자원낭비를 초래하는 방법이기에 항상 더 좋은 방법은 아닙니다.

데드락 예방기법은 4가지가 있습니다.
1. 상호배제 부정
    - 여러 트랜잭션이 동시에 자원에 접근하는 것을 허용하고, 충돌이 발생하는 경우 예외를 발생시키는 낙관적 락 방법이 있습니다.
    - 상품 재고는 여러 트랜잭션이 동시에 접근하고 충돌이 잦을 수 있기에 부적절하다고 판단했습니다.
    - 마찬가지로 포인트 충전, 포인트 감소 상황 역시 동시에 요청이 발생하는 경우 각각을 성공시키기 위해서 낙관적 락은 적합하지 않다고 판단했습니다.
2. 점유 및 대기 부정
    - 필요로 하는 모든 자원을 한번에 획득하게 하면 가능합니다.
    - 처음에는 벌크 조회 쿼리에 락을 걸면 가능하리라 생각했지만, 현재 사용 중인 MySQL 에서는 정말로 그런지 찾아보니 공식문서에서는 "레코드를 조우한 순간"에 락을 건다고 합니다. 즉, 여러 건을 쿼리를 실행해도 내부적으로는 하나씩 레코드를 찾고 의도한 방식으로 락을 걸기에 불완전한 방법이라고 판단했습니다.
    - > InnoDB performs row-level locking in such a way that when it searches or scans a table index, it sets shared or exclusive locks on the index records it encounters. Thus, the row-level locks are actually index-record locks.
      <br> [MySQL - 17.7.1 InnoDB Locking](https://dev.mysql.com/doc/refman/8.4/en/innodb-locking.html#innodb-next-key-locks)
3. 비선점 부정
    - 자원의 선점을 허용하게 하면 가능합니다.
    - 하지만 트랜잭션 중간에 자원을 선점하게 되면 락을 거는 이유가 없어지기 때문에 최후의 수단으로 타임아웃을 설정하여 일정 시간 후 선점을 허용하도록 해야 합니다. 그러면 데드락이 지속되지 않고, 한 트랜잭션에서 롤백되고 락을 해제하면서 다른 트랜잭션에서 레코드를 선점할 수 있게 됩니다.
    - JPA 의 @QueryHint 를 사용하여 타임아웃을 설정했습니다.
    ```
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @QueryHints(
            @QueryHint(
                    name = "jakarta.persistence.lock.timeout",
                    value = "5000"
            )
    )
    ```
4. 순환 대기 부정
    - 접근 대상인 자원들을 선형으로 분류 및 고유번호를 할당하고, 각 트랜잭션이 자원에 접근할 때 각 고유번호를 한 쪽 방향으로 순차적으로 접근함으로써 가능합니다.
    - 조회 대상인 상품은 PK 가 BIGINT 단일 컬럼이고, AUTO_INCREMENT 가 적용되어 있어서 선형적인 고유번호를 만족하는 상황입니다.
    - 아래 코드와 같이 조회할 순서를 정렬하고 한 건씩 조회함으로써 순환 대기 부정을 달성할 수 있었습니다.
    ```
    public void deductStocks(Map<Long, Integer> itemIdStockAmountMap) {
        List<Long> itemIds = new ArrayList<>(itemIdStockAmountMap.keySet());
        Collections.sort(itemIds); // (1)
        for (Long itemId : itemIds) { // (2)
            ItemStock itemStock = itemStockRepository.findByItemIdWithLock(itemId).orElseThrow(NoSuchItemStockException::new);
            itemStock.deductStock(itemIdStockAmountMap.get(itemStock.getItem().getId()));
        }
    }
    ```
    - (1) 에서 상품 ID 를 오름차순으로 정렬하여, 순차적으로 접근할 수 있게 합니다.
    - (2) 에서는 (1) 에서 정렬한 오름차순으로만 조회를 하기 때문에 교착상태에 빠지는 것을 막을 수 있게 됩니다.

</details>

## 동시성 제어 방식

<details>
  <summary>동시성 제어 방식</summary>

### 스레드 락

자바에서 동시성 제어를 위해서 synchonized 와 Lock 두 가지를 사용해볼 수 있습니다.

#### synchronized

```
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
```

- 장점
  - 키워드만으로 동기화가 가능하여 코드가 간결합니다.
  - 예외가 발생하더라도 자동으로 락이 해제됩니다.
- 단점
  - 고급 제어가 불가능하고 타임아웃 등이 불가능합니다.
- 복잡도
  - 구현이 가장 간단하고 복잡도가 낮습니다.
- 성능
  - 경쟁이 적은 경우에만 효율적입니다.
- 한계점
  - 하나의 애플리케이션 인스턴스 안에서만 제어가 가능합니다. 멀티 서버로 운영할 경우 동시성 제어가 불가능합니다.

#### Java Lock

```
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Counter {
    private int count = 0;
    private Lock lock = new ReentrantLock();

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }

    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}
```

- 장점
  - 타임아웃 등이 가능합니다.
  - 락을 원하는 위치에 유연하게 설정할 수 있습니다.
- 단점
  - 락의 획득과 해제를 명시적으로 관리해야 합니다.
- 복잡도
  - 명시적인 락 관리가 필요합니다.
  - 접근하는 자원 하나에 대해서만 구체적으로 락을 걸어야 불필요한 자원 낭비를 막을 수 있습니다.
- 성능
  - 락 알고리즘을 적용할 수 있습니다.
  - 공정한 락으로 기아 상태를 방지할 수 있습니다.
- 한계점
    - 하나의 애플리케이션 인스턴스 안에서만 제어가 가능합니다. 멀티 서버로 운영할 경우 동시성 제어가 불가능합니다.

### DB 락 - 낙관적 락
```
import javax.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@NoArgsConstructor
@Table(name = "users")
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @Version
    private Long version;
}
```

- 장점
  - 락을 사용하기 않기 때문에 데드락이 발생하지 않습니다.
  - 멀티 서버 환경에서도 동시성 제어가 가능합니다.
- 단점
  - 충돌 발생 시 재시도 로직이 필요할 수 있으며, 오버헤드 및 성능 저하로 이어질 수 있습니다.
- 복잡도
  - JPA 프레임워크를 사용할 경우 버전 관리 필드만 있으면 되기에 구현이 간단합니다.
  - 재시도 로직을 AOP 등으로 직접 구현해야 할 수 있습니다.
- 성능
  - 락 획득을 위한 대기가 없어 읽기 작업이 많은 경우 높은 성능을 발휘합니다.
  - 하지만 데이터 충돌이 잦은 수정 작업 등이 있다면 비효율적입니다.
- 한계점
  - 데이터 충돌이 잦은 경우 적합하지 않습니다.
  - 성공해야 할 요청이 마저 성공하지 못 해서 결국 비관적 락보다도 더 많은 자원을 사용해야 할 수 있습니다.
    - 언급했던 이커머스 시나리오에서 동시성 이슈가 발생할 수 있는 상황에서는, 비즈니스 로직 예외를 제외하면 각 요청들이 모두 성공해야 하기 때문에 적합하지 않습니다. 따라서 현재까지 구현된 이커머스 프로젝트에서 낙관적 락은 적용되지 않았습니다.
      - 포인트를 여러 번 충전하면 그 중 하나만 성공하는 게 아니라 모두 성공해야 합니다. 만약 정말로 모든 요청이 실수가 아니라 의도적으로 충전하려는 상황에서도 그렇고, PG 사를 거친 결제 승인 요청이 필요한 상황에서도 비관적 락 요청이 필요한 상황이 있습니다.
      > 만약 포인트만 충전하는 상황이라면, 낙관적 락으로 실수로 동시에 발생한 요청, 소위 "따닥"을 적은 리소스로 제어할 수 있습니다.
      > 
      > 하지만 실제 포인트 충전을 위해서는 PG 사에 결제 요청을 해야 할 거고, (그 경우 주문 아이디, 결제 키 등이 있다고 하더라도 같은 주문에 대하여)낙관적 락을 사용하면 각 요청이 아직 결제 완료 전 상태의 주문을 조회해서 PG 사에 여러 번 결제 승인이 요청될 수도 있습니다.
      > 
      > 이 경우까지 고려하면, 포인트 충전의 동시성 제어는 두 가지 방안이 있을 것 같습니다. 
      > 1) 낙관적 락과 PG 사 요청 시의 멱등키 사용. 단, PG 사에 따라 멱등키를 지원하지 않을 수도 있기에 PG 사에 따라 제약이 있을 수 있습니다.
      > 2) 비관적 락을 사용하면 동일한 주문 아이디에 대해서 PG 사 결제 승인 요청 전에 레코드 상태를 검증할 수 있고, PG 사가 멱등키를 지원하지 않아도 로직의 제어가 가능합니다.
      - 여러 번의 재고 차감 시도가 있을 때, 재고가 충분할 때는 모두 성공해야 합니다.
      - 여러 번의 포인트 차감 시도가 있을 때, 포인트가 충분할 때는 모두 성공해야 합니다.
  - 분산 DB 환경에서 여러 트랜잭션을 사용하게 되어 복잡도가 올라갈 수 있습니다.

### DB 락 - 비관적 락

- 장점
  - 다른 트랜잭션의 접근을 차단하여 강력한 일관성과 무결성을 보장합니다.
  - 데이터 수정과 충돌이 잦은 경우, 수많은 동시 요청에 대해 재시도를 하지 않아도 됩니다.
    - 예를 들어 낙관적 락을 사용하는 경우 재고 차감을 위해 10,000 번의 요청이 발생하면 1번의 요청만 발생하고, 다시 9,999 번의 요청이 모두 재시도되어야 하기 때문에 비효율적입니다.
- 단점
  - 데드락이 발생할 수 있기에 예방, 탐지, 복구 등 데드락 해결방법이 필요합니다.
  - 락 대기 시간으로 인해 성능이 저하될 수 있습니다.
- 복잡도
  - JPA 프레임워크를 사용할 경우 @Lock 을 사용하여 간단하게 구현할 수 있습니다.
  - 데드락 방지 로직이 필요합니다.
  - 적절한 범위의 락 사용이 필요합니다.
- 성능
  - 데이터 충돌이 잦은 경우 적합합니다.
  - 과도한 락 경합에 의해 성능이 저하될 수 있습니다.
- 한계점
  - 분산 DB 환경에서 일관성이 제공되지 않을 수 있습니다.

### 분산락

만약 우리가 제공하는 서비스의 애플리케이션 인스터스가 하나라면 Java Lock 으로 해결할 수도 있습니다. 하지만 인스턴스가 여러 개라면 일관된 락을 위해 DB Lock 을 사용할 필요가 있습니다.

마찬가지로 만약 DB 가 하나라면 DB Lock 으로 일관된 락을 제공할 수 있습니다. 하지만 만약 도메인 별로 DB 를 각각 구성한다면 DB Lock 도 부족할 수 있습니다.

트랜잭션끼리는 락이 공유되지 않기에 일관성이 지켜지지 않을 수 있습니다. 예를 들어, 분산 DB 환경에서 한 스레드가 여러 개의 트랜잭션을 확보하고 각각의 DB 에서 락을 획득한 후 한 트랜잭션이 장애가 발생하면, 다른 트랜잭션들이 락을 해제하지 않고 로직이 종료될 위험이 있습니다.

이를 극복하고자 동시성 제어를 관리하는 중앙집중식 서버를 통해 동시성 제어를 하는 전략을 분산락이라고 합니다.

etcd, consul 등의 여러 도구까지 포함하여, 분산락을 직접 구현하는 등의 방법이 여러 가지 있지만 Spring 은 LockRegistry 라는 인터페이스를 제공하고 있으며, 추가로 Spring Integration 이라는 프로젝트를 통해 JDBC, Hazelcast, Redis, Zookeeper 4가지의 구현된 라이브러리를 제공합니다.

#### Spring 분산락 구현체 비교

| 항목         | JDBC                   | Hazelcast             | Redis              | Zookeeper              |
|------------|------------------------|-----------------------|--------------------|------------------------|
| **장점**     | 기존 DB 활용, 쉬운 구현        | 고성능, 분산 잠금, 확장성       | 고성능, 성숙한 기술, 쉬운 구현 | 강력한 일관성, 분산 동기화 전용     |
| **단점**     | 낮은 성능, 스케일링 한계, 경합 가능성 | 추가 인프라 필요, 메모리 사용량 높음 | 단일 장애점, 잠금 관리 복잡성  | 복잡한 설정, 운영 부담, 성능 오버헤드 |
| **성능**     | 낮음                     | 높음                    | 높음                 | 중간                     |
| **효율성**    | 낮음                     | 높음                    | 높음                 | 중간                     |
| **구현 복잡도** | 낮음                     | 높음                    | 중간                 | 높음                     |

- JDBC는 간단한 구현과 기존 인프라 활용 측면에서 유리하지만, 성능과 확장성 면에서 한계가 있습니다. 그리고 이름을 들어보면 (비록 분산락으로 분류되긴 했지만)분산락이 아닌 것 같은 느낌이 듭니다.
- Hazelcast는 고성능과 확장성을 제공하지만, 추가적인 학습과 인프라 관리가 필요합니다.
  - 개인적으로는 Redis 와 비슷하다는 느낌을 받았으나 커뮤니케이션이 많이 활성화되지는 않았다는 느낌을 받았습니다. 구글 트렌드 비교검색 결과로도 Redis 에 비해 확실히 관심도가 적었습니다.
  ![구글 트렌드 검색 결과](https://raw.githubusercontent.com/psam1017/hhplus-ecommerce/refs/heads/STEP11/docs/concurrency/google-trend.png)
- Redis는 높은 성능과 비교적 쉬운 구현이 가능하지만, 잠금 관리(키 이름 등)에 신경 써야 하고, 고가용성을 위한 추가 설정이 필요할 수 있습니다.
- Zookeeper는 분산 환경에서의 일관성 보장이 가능하지만, 설정과 관리의 복잡도가 높습니다.

> 추가로, 스프링이 분산락 구현체로 제공하지는 않지만 카프카도 동시성 제어를 위해 사용할 수 있습니다. 동일한 키가 해싱 등을 이용해서 동일한 파티션을 사용하게 하면 순서가 보장이 되므로 일관된 처리가 가능합니다. 그리고 Redis 가 제공하는 분산락처럼 시간 동기화 문제도 생기지 않습니다.
> 
> 하지만 카프카의 도입은 Zookeeper 와 마찬가지로 복잡한 설정과 운영 부담을 초래할 수 있습니다. 
> 
> 예를 들어, 애플리케이션은 성공 로직을 수행하고 커밋을 함으로써, 카프카의 파티션을 타는 메시지들은 트랜잭션 범위를 벗어났으므로 실패되어야 할 데이터들을 직접 이전 상태로 복구시켜야 하며, 그 과정에서 발생한 예외에 대한 처리도 필요합니다.
> 
> 만약 주문 로직에 의해 상품별로 재고를 차감시키도록 이벤트를 발행하면, 하나의 주문에 대한 상품들이 서로 다른 파티션을 타고 컨슘될 것이므로 주문 컨슈머 쪽에서 재고를 차감할 상품과 함께 주문 아이디로 같이 받아서 검증하는 등 알고리즘적 복잡도가 상당히 올라갑니다.

### 적용할 락(RedLock)

레디스는 RedLock 이라는 분산락을 제공합니다. 이 분산락은 여러 개의 단일 레디스 노드를 사용할 수 있어서, 단일 장애 지점 문제를 극복했지만, 이 여러 개의 노드들 간 동기화된 시계(synchronized clock)가 없기 때문에 다음과 같은 상황에서 장애가 발생할 수 있습니다.

(**한계점 참고** : [[Redis] 레디스가 제공하는 분산락(RedLock)의 특징과 한계](https://mangkyu.tistory.com/311))

- Clock Drift
- 애플리케이션 중단 또는 네트워크 지연
- Java Garbage Collector 의 동작으로 인한 락 만료

하지만 그럼에도 RedLock 은, 다른 분산락 구현체들에 비해 다음과 같은 장점을 가집니다.

- Hazelcast 보다 더 많은 커뮤니케이션이 활성화되어 있다.
- Zookeeper, Kafka 보다 시스템 복잡도가 낮고 구현 난이도가 낮다.
- Lock 에 타임아웃을 설정할 수 있다.
- LuaScript 로 Atomic 연산을 제공한다.
- Pub/Sub 사용으로 리소스를 절약할 기회가 더 높다.

사실 일관성을 지키기 위해서라면 Zookeeper 를 사용해야 한다는 생각이 듭니다. 기술 조사를 위해 참고한 (위에서 언급한)블로그에서도 더욱 안전한 분산락을 보장하기 위해 Zookeeper 사용을 언급했습니다.

하지만 Redis 의 분산락으로도 높은 수준의 분산락을 보장할 수 있기에 여전히 Redis 도 유용하게 사용할 여지가 있습니다. 그런 면에서 이 기술의 도입을 단순히 과제라고 생각할 게 아니라, 현실의 회사 프로젝트라고 생각한다면 일단 기한 내에 구현하고 동작을 시킬 수 있어야 합니다. 실제로 과제도 마감 기한과 패스여부가 존재합니다.

Redis 는 Redisson 이라고 하는 분산락을 편리하게 사용할 수 있는 클라이언트 라이브러리가 존재하며, 구현 난이도도 낮은 편이며 조사했을 때 체감상 가장 많은 레퍼런스와 블로그 포스트가 존재했습니다. 이는 그만큼 사용자 층도 두텁다는 뜻이리라 생각합니다.

추가적인 고도화는 그 다음이라고 생각하고 현실적으로 '내가 기간 내에 구현할 수 있는 최선'을 다하는 것도 필요하다고 생각해서 Redis 를 적용하기로 했고, 이후 시간적 여유가 허락된다면 Zookeeper 로의 전환을 고려해보고자 합니다.

</details>
