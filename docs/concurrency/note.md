# 이커머스 동시성 이슈 분석 보고서

## 목차
- [동시성 이슈란?](#동시성-이슈란)
- [이커머스 시나리오에서 발생할 수 있는 동시성 이슈](#이커머스-시나리오에서-발생할-수-있는-동시성-이슈)
- [동시성 제어를 위한 락](#동시성-제어를-위한-락)
- [동시성 제어 구현](#동시성-제어-구현)

---

## 동시성 이슈란?
<details>
  <summary>동시성 이슈란?</summary>

동시성 이슈란 공유될 수 있는 하나의 자원에 대해 여러 트랜잭션, 스레드, 프로세스 또는 작업 등이 동시에 접근할 때 충돌이 일어나는 것을 의미합니다.

예를 들어, 하나의 자원이 속성으로 0이라는 값을 가지고 있을 때, 1씩 증가하는 요청을 여러 번 한다고 가정해봅시다.

만약 이 요청이 순차적으로 발생히여 충돌이 생기지 않는다고 하면 다음과 같이 수정됩니다. 

- A : 현재값(0) + 1 -> 1 로 업데이트
- B : 현재값(1) + 1 -> 2 로 업데이트
- C : 현재값(2) + 1 -> 3 로 업데이트
- ...

하지만, 이 요청이 순차적으로 발생한 게 아니라 동시에 발생한다면 다음과 같이 수정됩니다.

- A : 현재값(0) + 1 -> 1 로 업데이트
- A' : 현재값(0) + 1 -> 1 로 업데이트
- A'' : 현재값(0) + 1 -> 1 로 업데이트
- ...

이렇게 충돌이 발생하면 1씩 증가하는 요청을 아무리 여러 번 요청하더라도 그 값이 제대로 반영되지 않을 수 있기 때문에 동시성 이슈가 발생하지 않도록 제어하는 것은 굉장히 중요합니다.

이것을 보고 소위 '동시성 제어'라고 합니다.

</details>

## 이커머스 시나리오에서 발생할 수 있는 동시성 이슈

<details>
  <summary>이커머스 시나리오에서 발생할 수 있는 동시성 이슈</summary>

- 이커머스 시나리오 프로젝트에서도 동시성 이슈가 발생할 수 있는 솽황이 몇 가직 있습니다.

### 포인트 충전을 위해 포인트 레코드에 접근

포인트를 충전하는 상황에서 여러 번의 결제를 수행하더라도 1번만 포인트가 충전되는 문제 상황이 생길 수 있습니다.

- A : 현재 포인트(100) + 100 -> 200 으로 업데이트
- A' : 현재 포인트(100) + 100 -> 200 으로 업데이트
- A'' : 현재 포인트(100) + 100 -> 200 으로 업데이트

### 주문/결제 시 - 포인트 감소를 위해 포인트 레코드에 접근

포인트를 사용하여 주문을 하는 상황에서 여러 번 주문을 했음에도 1번만 포인트가 사용되는 문제 상황이 생길 수 있습니다.

- B : 현재 포인트(1000) - 100 -> 900 으로 업데이트
- B' : 현재 포인트(1000) - 100 -> 900 으로 업데이트
- B'' : 현재 포인트(1000) - 100 -> 900 으로 업데이트

### 주문/결제 시 - 재고 차감을 위해 재고 레코드에 접근

1개 밖에 남지 않은 상품을 주문할 때 여러 번의 주문 모두가 구매에 성공하는 문제 상황이 생길 수 있습니다.

- C : 현재 재고수량(1) - 1 -> 0 으로 업데이트 && 주문 성공
- C' : 현재 재고수량(1) - 1 -> 0 으로 업데이트 && 주문 성공
- C'' : 현재 재고수량(1) - 1 -> 0 으로 업데이트 && 주문 성공

</details>

## 동시성 제어를 위한 락

<details>
  <summary>동시성 제어를 위한 락</summary>

동시성 이슈를 해결하기 위해서는 락(Lock)이라는 개념을 사용합니다. 락은 공유 자원에 대한 접근을 제어하여 동시에 여러 프로세스나 스레드가 동일한 자원에 접근하는 것을 방지하는 메커니즘입니다. 이를 통해 데이터의 무결성을 유지하고 예기치 않은 충돌이나 오류를 예방할 수 있습니다.

### 낙관적 락과 비관적 락
락에는 낙관적 락과 비관적 락이 있습니다.

- 낙관적 락
  - 데이터 충돌이 드물다고 가정하고, 데이터 수정 시 충돌 여부를 검사하여 문제가 없으면 업데이트를 진행합니다.
  - 버전 번호 또는 타임스탬프를 이용하여 데이터 변경 여부를 확인합니다.
  - 락을 걸지 않기에 시스템 성능 저하가 적다는 장점이 있습니다.
  - 충돌이 발생하면 재시도 로직이 필요할 수 있으며, 동시에 여러 충돌이 발생하여 실패하면 10버 성공해야 할 게 7번만 성공하는 등 문제가 생길 수 있습니다.
    - 충돌이 드물거나, 또는 한 건만 성공하면 되는 경우 등의 상황에서 적합합니다.
- 비관적 락
  - 데이터 충돌이 빈번하다고 가정하고, 데이터에 접근할 때 락을 걸고 다른 작업을 접근하지 못 하게 막습니다.
  - java 의 synchronized, db 의 select ... for update 등 시스템적인 방법이 있습니다.
  - 데이터 충돌을 사전에 방지하여 안정성을 높일 수 있다는 장점이 있습니다.
  - 락에 따른 대기 시간이 발생하여 성능이 저하될 수 있습니다.
    - 충돌이 빈번하거나, 여러 건의 시도가 하나씩 성공해야 하는 경우 등의 상황에서 적합합니다.

### 데드락
락에 의해 발생할 수 있는 문제 중에 데드락이라는 것도 있습니다. 데드락은 서로 다른 작업이 각자에게 필요로 하는 자원을 상대방이 소유하고 있어서 서로의 작업이 끝나기를 대기해버리는 상황입니다.

![데드락 이미지](https://github.com/user-attachments/assets/7d51cb86-5988-4b9f-8ac8-98ecdb98dd5f)

데드락은 예방, 회피, 탐지, 복구 등의 방법으로 해결할 수 있습니다. 이 방법들을 실현하는 방식도 많이 있기 때문에 이 프로젝트에서 적용된 순환 대기 부정만 짧게 적어볼까 합니다.

순환 대기 부정이란 데드락 예방 기법 중 하나로, 데드락이 생기기 전에 순환 대기가 발생하지 않도록 하는 방법입니다. 이는 접근 대상인 자원들을 선형으로 분류 및 고유번호를 할당하고, 각 프로세스가 자원에 접근할 때는 각 고유번호를 한 쪽 방향으로 순차적으로 접근함으로써 가능합니다. 사실 처음에는 SELECT ... FOR UPDATE 로 여러 건을 조회하면 한 번에 여러 레코드가 잠길 것이라고 알았는데, 웬지 불안해서 더 찾아보니 DB 엔진도 내부적으로는 레코드를 먼저 찾고, 그 레코드를 만난 순간 락을 걸기 때문에, 결론적으로는 한 레코드씩 걸게 된다고 합니다.

```
public void deductStocks(Map<Long, Integer> itemIdStockAmountMap) {
    List<Long> itemIds = new ArrayList<>(itemIdStockAmountMap.keySet());
    Collections.sort(itemIds); // (1)
    for (Long itemId : itemIds) { // (2)
        ItemStock itemStock = itemStockRepository.findByItemIdWithLock(itemId).orElseThrow(NoSuchItemStockException::new);
        itemStock.deductStock(itemIdStockAmountMap.get(itemStock.getItem().getId()));
    }
}
```

위 코드가 순환 대기 부정을 적용한 코드입니다. 각 상품의 재고는 동시성 제어 대상에 해당하며, id 컬럼을 PK 로 가지고 있는데 auto_increment 가 적용되어 있습니다.

- (1) 에서 상품 ID 를 오름차순으로 정렬하여, 오직 순차적으로만 접근할 수 있게 합니다.
- (2) 에서는 (1) 에서 정렬한 오름차순으로만 조회를 하기 때문에 교착상태에 빠지는 것을 막을 수 있게 됩니다.

한편, 이 방법은 서로 다른 작업들끼리 하나라도 레코드가 겹치면 그만큼 대기를 해야 하기 때문에 자원 낭비가 심한 편이긴 합니다. 하지만 그만큼 직관적인 방법이기도 합니다.

</details>

## 동시성 제어 구현

<details>
  <summary>동시성 제어 구현</summary>

### 분산락의 필요성
만약 우리가 제공하는 서비스의 애플리케이션 인스터스가 하나거나, 아니면 DB 가 하나라면 Java Lock 이나 DB Lock 을 사용하는 것으로 충분할 수 있습니다.

하지만 만약 인스턴스가 여러 대라면, 그리고 DB 도 도메인마다 DB 가 완전 분리되어 있다면, 일관된 락을 제공하지 못 하게 됩니다. 이를 극복하고자 동시성 제어를 수행하는 중앙집중식 서비스 또는 서버를 통해 동시성 제어를 하는 전략을 분산락이라고 합니다.

etcd, consul 등의 여러 도구까지 포함하여, 분산락을 직접 구현하는 등의 방법이 여러 가지 있지만 Spring 은 Spring Integration 이라는 프로젝트를 통해 LockRegistry 라는 인터페이스를 제공하고 있으며, 추가로 JDBC, Hazelcast, Redis, Zookeeper 4가지 서버에 대한 구현된 LockRegistry 를 제공합니다.

### 분산락 기술 비교

| 항목         | JDBC                   | Hazelcast             | Redis              | Zookeeper              |
|------------|------------------------|-----------------------|--------------------|------------------------|
| **장점**     | 기존 DB 활용, 쉬운 구현        | 고성능, 분산 잠금, 확장성       | 고성능, 성숙한 기술, 쉬운 구현 | 강력한 일관성, 분산 동기화 전용     |
| **단점**     | 낮은 성능, 스케일링 한계, 경합 가능성 | 추가 인프라 필요, 메모리 사용량 높음 | 단일 장애점, 잠금 관리 복잡성  | 복잡한 설정, 운영 부담, 성능 오버헤드 |
| **성능**     | 낮음                     | 높음                    | 높음                 | 중간                     |
| **효율성**    | 낮음                     | 높음                    | 높음                 | 중간                     |
| **구현 복잡도** | 낮음                     | 높음                    | 중간                 | 높음                     |

- JDBC는 간단한 구현과 기존 인프라 활용 측면에서 유리하지만, 성능과 확장성 면에서 한계가 있습니다.
- Hazelcast는 고성능과 확장성을 제공하지만, 추가적인 학습과 인프라 관리가 필요합니다.
  - 개인적으로는 Redis 와 비슷하다는 느낌을 받았으나 커뮤니케이션이 많이 활성화되지는 않았다는 느낌을 받았습니다. 구글 트렌드 비교검색 결과로도 Redis 에 비해 확실히 관심도가 적었습니다.
- Redis는 높은 성능과 비교적 쉬운 구현이 가능하지만, 잠금 관리에 신경 써야 하고, 고가용성을 위해 추가 설정이 필요합니다.
- Zookeeper는 분산 환경에서의 일관성 보장이 가능하지만, 설정과 관리의 복잡도가 높습니다.

### 채택할 기술은 레디스

레디스는 RedLock 이라는 분산락을 제공합니다. 이 분산락은 여러 개의 단일 레디스 노드를 사용함으로, 단일 장애 지점이 될 수 있다는 문제를 극복했지만, 이 여러 개의 노드들 간 동기화된 시계(synchronized clock)가 없기 때문에 다음과 같은 상황에서 장애가 발생할 수 있습니다.

(**한계점 참고** : [[Redis] 레디스가 제공하는 분산락(RedLock)의 특징과 한계](https://mangkyu.tistory.com/311))

- Clock Drift
- 애플리케이션 중단 또는 네트워크 지연
- Java Garbage Collector 의 동작으로 인한 락 만료

하지만 그럼에도 RedLock 은 다음과 같은 장점을 가집니다.

- Hazelcast 보다 더 많은 커뮤니케이션이 활성화되어 있다. [구글 트렌드 비교 이미지](https://github.com/user-attachments/assets/e126b256-c4cb-435d-986f-9aecddf3212f)
- Zookeeper 보다 시스템 복잡도가 낮고 구현 난이도가 낮다.
- Lock 에 타임아웃을 설정할 수 있다.
- LuaScript 로 Atomic 연산을 제공한다.
- Pub/Sub 사용으로 리소스를 절약할 기회가 더 높다.

사실 일관성을 지키기 위해서라면 Zookeeper 를 사용해야 한다는 생각이 듭니다. 기술 조사를 위해 참고한 (위에서 언급한)블로그에서도 더욱 안전한 분산락을 보장하기 위해 Zookeeper 를 언급했습니다.

하지만 Redis 의 분산락으로도 높은 수준의 분산락을 보장할 수 있기에 여전히 Redis 도 유용하게 사용할 여지가 있습니다. 그런 면에서 이 기술의 도입을 단순히 과제라고 생각할 게 아니라, 현실의 회사 프로젝트라고 생각한다면 일단 기한 내에 구현하고 동작을 시킬 수 있어야 합니다. 실제로 과제도 마감 기한과 패스여부가 존재하기도 합니다.

Redis 는 Redisson 이라고 하는 분산락을 편리하게 사용할 수 있는 클라이언트 라이브러리도 존재하며, 구현 난이도도 낮은 편이며 조사했을 때 체감상 가장 많은 레퍼런스와 블로그 포스트가 존재했습니다. 이는 그만큼 사용자 층도 두텁다는 뜻이리라 생각합니다.

추가적인 고도화는 그 다음이라고 생각하고 현실적으로 '내가 기간 내에 구현할 수 있는 최선'을 다하는 것도 필요하다고 생각해서 Redis 를 사용하기로 했고, 이후 시간적 여유가 허락된다면 Zookeeper 로의 전환을 고려해보고자 합니다.

</details>
